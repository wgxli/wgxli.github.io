(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{445:function(e,n,t){"use strict";t.r(n);var a=t(477),r=t(0),i=t.n(r),o=t(472);function l(){var e=Object(a.a)(["[0 leq p cdot (dn' - 2pd') < 2d',]"],["\\[0 \\leq p \\cdot (dn' - 2pd') < 2d',\\]"]);return l=function(){return e},e}function c(){var e=Object(a.a)(["[pi = \frac{2p}{2k + 1} + \frac{2epsilon}{2k+1}.]"],["\\[\\pi = \\frac{2p}{2k + 1} + \\frac{2\\epsilon}{2k+1}.\\]"]);return c=function(){return e},e}function s(){var e=Object(a.a)(["[p + epsilon = left(k + \frac{1}{2}\right) pi,]"],["\\[p + \\epsilon = \\left(k + \\frac{1}{2}\\right) \\pi,\\]"]);return s=function(){return e},e}n.default=function(){return i.a.createElement(i.a.Fragment,null,String.raw(s()),i.a.createElement("p",null,"which rearranges to"),String.raw(c()),i.a.createElement("p",null,"Moreover, for small \\(\\epsilon\\), we have the excellent approximation"," \\(\\tan{p} \\sim \\epsilon^{-1}\\)",". Requiring "," \\(\\tan{p} > p\\)"," then imposes the condition \\(p \\epsilon \\in [0, 1)\\), or"),"\\[p \\cdot \\left[(2k + 1) \\, \\pi - 2p\\right] \\in [0, 2).\\]",i.a.createElement("p",null,"Summing up the above, we want rational approximations to \\(\\pi\\) that are a bit too small, but ",i.a.createElement("i",null,"exceedingly")," close.",i.a.createElement(o.d,{id:1}),"How do we go about looking for such approximations? The continued fraction expansion, of course!"),i.a.createElement(o.a,{language:"python"},'def continued_fraction_coefficients():\n    """Read the continued fraction coefficients of pi from a file."""\n    # Left as an exercise to the reader\n\ndef rational_approximations():\n    """Generate the sequence of best rational approximants of pi."""\n    # We use the isomorphism between SL_2(R) and the fractional linear transformations.\n    # We start with the function 1/x, and repeatedly pre-compose\n    # with 1/(a + x), where a is the continued fraction coefficient.\n    # We return the limit of the current rational function as x \u2192 \u221e.\n    n0, n1 = 0, 1\n    d0, d1 = 1, 0\n    for a in continued_fraction_coefficients():\n        (n0, n1) = (n1, a * n1 + n0)\n        (d0, d1) = (d1, a * d1 + d0)\n        yield (n1, d1)\n'),i.a.createElement("p",null,"For each rational approximation \\(n/d\\) with \\(n = 2p\\) even and \\(d = 2k+1\\) odd, we\u2019d like to check if \\(p \\cdot (d \\pi - 2p) \\in [0, 2)\\). But since we\u2019re going to be working with huge numbers, we want to avoid floating point math if possible."),i.a.createElement("p",null,"One way to accomplish this is to replace the \\(\\pi\\) in this check with an even ",i.a.createElement("i",null,"better")," rational approximation \\(n' / d'\\). For this check to be accurate, we\u2019d like \\(d' \\gg p \\cdot d\\). The condition then becomes"),i.a.createElement("p",{className:"emphasis"},String.raw(l())),i.a.createElement("p",null,"which only involves integer math. Summing up the above:"),i.a.createElement(o.a,{language:"python",start:17},"gen1 = rational_approximations()\ngen2 = rational_approximations()\n\nfor n, d in gen1:\n    # We want n/d with n even, d odd.\n    if n % 2 != 0 or d % 2 == 0: continue\n    p = n // 2\n\n    # We'd like d' >> pd; I found that d' >= 4pd works fine.\n    threshold = 4 * p * d\n    while True:\n        nn, dd = next(gen2)\n        if dd > threshold:\n            break\n\n    # Our integer-math-only check for an 'interesting' value of p.\n    if 0 <= p * (d*nn - 2*p*dd) < 2*dd:\n        # At this point, we should have tan(p) > p.\n        # All that remains is a primality check:\n        if is_probable_prime(p):\n            print(p)\n"),i.a.createElement("p",null,"If you\u2019re following along, you might want to add more logging just to see what the code is doing. All that remains is to define a reasonable probabilistic primality test ",i.a.createElement("code",null,"is_probable_prime"),". Personally, I got the best performance by doing trial division on primes up to a million, then calling ",i.a.createElement("a",{href:"https://sourceforge.net/projects/openpfgw/"},"PFGW")," via ",i.a.createElement("code",null,"subprocess"),". If you want to stay within Python, the ",i.a.createElement("a",{href:"https://pypi.org/project/gmpy2/"},"gmpy2")," library is also a reasonable option:"),i.a.createElement(o.a,{language:"python"},"from gmpy2 import is_strong_prp, is_prime\n\nPRIMES = [k for k in range(1, 1000000) if is_prime(k)]\ndef is_probable_prime(n):\n    if any(n % p == 0 for p in PRIMES):\n        return False\n    return is_strong_prp(n, 3)\n"),i.a.createElement("p",null,"The verdict? In less than a second, we reproduce the 46-digit prime mentioned at the start of the blog post. In two or three seconds, we find a 1017-digit prime solution (which Matt ",i.a.createElement("a",{href:"https://twitter.com/standupmaths/status/1296400194721001472"},"mentioned"),"), which begins and ends as"),"\\[p = 230835870782\\dots 610326005069.\\]",i.a.createElement("p",null,"And after a few hours, we find the monstrous 35,085-digit prime"),"\\[p = 409461998988\\dots 829370185991,\\]",i.a.createElement("p",null,"which, at the time of writing, I believe Matt (and, perhaps, everybody else in the world) is unaware of."),i.a.createElement("p",null,"I think that's enough for today."),i.a.createElement(o.c,null,i.a.createElement(o.b,{id:1},"More precisely, we want an approximation accurate to the order of denominator squared. The constants are a bit too small to apply ",i.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Dirichlet%27s_approximation_theorem"},"Dirichlet\u2019s approximation theorem")," directly, so we aren\u2019t guaranteed infinitely many solutions (although I suspect there are).")))}},472:function(e,n,t){"use strict";t.d(n,"e",function(){return s}),t.d(n,"c",function(){return p}),t.d(n,"b",function(){return u}),t.d(n,"d",function(){return d}),t.d(n,"a",function(){return m});var a=t(0),r=t.n(a),i=t(547),o=t(474),l=t(475),c=t(476);t(473);function s(e){var n=e.desktopSource,t=e.mobileSource,a=e.alt;return r.a.createElement(r.a.Fragment,null,r.a.createElement("img",{src:n,className:"desktop",alt:a}),r.a.createElement("img",{src:t,className:"mobile",alt:a}))}function p(e){var n=e.children;return r.a.createElement("section",{className:"footnotes"},r.a.createElement("hr",null),r.a.createElement("h2",null,"Footnotes"),r.a.createElement("ol",null,n))}function u(e){var n=e.children,t=e.id;return r.a.createElement("li",null,r.a.createElement("span",{className:"label"},"[",t,"]"),n,r.a.createElement("a",{className:"reference return",href:"#reference-".concat(t)},"\u21a9"),r.a.createElement("span",{className:"anchor",id:"footnote-".concat(t)}))}function d(e){var n=e.id;return r.a.createElement("a",{className:"reference",href:"#footnote-".concat(n)},r.a.createElement("sup",null,"[",n,"]"),r.a.createElement("span",{className:"anchor",id:"reference-".concat(n)}))}function m(e){var n=e.children,t=e.language,a=e.start;return r.a.createElement(i.a,{language:t,style:c.a,showLineNumbers:!0,startingLineNumber:a||1},n)}i.a.registerLanguage("javascript",o.a),i.a.registerLanguage("python",l.a)},473:function(e,n,t){},477:function(e,n,t){"use strict";function a(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}t.d(n,"a",function(){return a})}}]);
//# sourceMappingURL=7.9931a394.chunk.js.map